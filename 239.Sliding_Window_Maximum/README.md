# 239. Sliding Window Maximum

## 問題描述

給定一個整數數組 `nums` 和一個滑動窗口大小 `k`，找出每個窗口中的最大值。

**範例：**
```
輸入: nums = [1,3,-1,-3,5,3,6,7], k = 3
輸出: [3,3,5,5,6,7]

解釋:
窗口位置                最大值
---------------        -----
[1  3  -1] -3  5  3  6  7      3
 1 [3  -1  -3] 5  3  6  7      3
 1  3 [-1  -3  5] 3  6  7      5
 1  3  -1 [-3  5  3] 6  7      5
 1  3  -1  -3 [5  3  6] 7      6
 1  3  -1  -3  5 [3  6  7]     7
```

**限制條件：**
- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4
- 1 <= k <= nums.length

---

## 解法比較

### 解法 1: Max Heap - O(n log n)

**思路：**
- 用最大堆維護窗口內的元素（存儲 value 和 index）
- 每次窗口滑動，加入新元素到堆
- 檢查堆頂是否在窗口外，如果是就移除
- 堆頂就是當前窗口最大值

**時間複雜度：** O(n log n)
- 每個元素入堆一次：O(log n)
- 最壞情況下每個元素出堆一次：O(log n)
- 總共 n 個元素 → O(n log n)

**空間複雜度：** O(n) - 堆最多存 n 個元素

**優缺點：**
- ✅ 較容易理解（標準堆操作）
- ❌ O(n log n) 時間複雜度
- ❌ 需要額外處理過期元素
- ❌ 空間複雜度 O(n)

### 解法 2: Monotonic Deque (單調雙端隊列) - O(n) ⭐

**思路：**
1. 維護一個遞減的雙端隊列（存儲索引）
2. 隊首永遠是當前窗口的最大值索引
3. 新元素進來時，從隊尾移除所有比它小的元素（它們永遠不可能是最大值）
4. 如果隊首索引超出窗口，從隊首移除

**時間複雜度：** O(n)
- 每個元素最多進隊一次：O(1)
- 每個元素最多出隊一次：O(1)
- 總共 n 個元素 → O(n)

**空間複雜度：** O(k) - 雙端隊列最多存 k 個元素

**優缺點：**
- ✅ O(n) 最優時間複雜度
- ✅ 空間複雜度更優 O(k)
- ✅ 每個元素最多進出隊列一次
- ❌ 思路相對不直觀（需要理解單調性維護）

**性能對比：**
```
當 n = 10^5, k = 10^4 時：
Heap:  ~10^5 * log(10^5) ≈ 1,660,000 次操作
Deque: ~10^5 次操作（快 16 倍！）
```

---

## Monotonic Deque 詳解

### 核心機制

Monotonic Deque 通過兩個機制協同工作，確保隊首永遠是當前窗口的最大值：

#### 機制 1：維護窗口合法性（main.go:113-115）

```go
// 移除已經滑出窗口的元素
if len(deque) > 0 && deque[0] < i-k+1 {
    deque = deque[1:] // 移除隊首
}
```

- **目的：** 清理「已經滑出窗口」的元素
- **檢查位置：** 隊首（最舊的元素）
- **操作：** 從隊首移除
- **`i-k+1` 是什麼？** 當前窗口的左邊界

**範例：**
```
k = 3, i = 5
窗口左邊界 = 5 - 3 + 1 = 3

nums:  [1,  3, -1, -3,  5,  3,  6,  7]
index:  0   1   2   3   4   5   6   7
                    ↑---------↑
                 左邊界      右邊界(i)
                    [-3, 5, 3] ← 當前窗口

如果 deque[0] = 2：
檢查：2 < 3? ✓ → 移除（索引 2 已滑出窗口）
```

#### 機制 2：維護遞減性質（main.go:120-122）

```go
// 從隊尾移除所有比當前元素小的元素
for len(deque) > 0 && nums[deque[len(deque)-1]] < nums[i] {
    deque = deque[:len(deque)-1] // 移除隊尾
}
```

- **目的：** 清理「永遠不可能成為最大值」的元素
- **檢查位置：** 隊尾（最新加入的位置）
- **操作：** 從隊尾移除
- **關鍵洞察：** 如果一個元素比新元素小且位置更舊，它在未來的所有窗口中都不可能是最大值

**範例：**
```
當前要加入 nums[4] = 5
deque 目前：[2, 3]
             ↓  ↓
   對應值：[-1, -3]

執行 while loop：
1. nums[3]=-3 < nums[4]=5? ✓ → 移除索引 3
2. nums[2]=-1 < nums[4]=5? ✓ → 移除索引 2
3. deque 變成 []

為什麼移除？
- -1 和 -3 比 5 小
- 它們位置比 5 舊
- 未來任何包含 5 的窗口，最大值都不可能是它們
```

#### 兩個機制的分工總結

| 步驟 | 位置 | 目的 | 保證 |
|------|------|------|------|
| 機制1 (113-115行) | 隊首 | 窗口合法性 | deque 中的索引都在當前窗口內 |
| 機制2 (120-122行) | 隊尾 | 維護遞減性 | deque[0] 對應的值是最大的 |

**兩者配合 → deque[0] 一定是當前窗口內的最大值索引！**

### 完整執行流程圖解

```
nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3

圖例：
[...] = deque（存儲索引）
{...} = 當前窗口
→ = deque 頭部（最大值）

──────────────────────────────────────────────────────────

步驟 0: i=0, nums[0]=1
───────────────────────────────
nums:  {1}  3  -1  -3   5   3   6   7
index:  0   1   2   3   4   5   6   7

deque: [0]
       →
操作：加入索引 0
窗口未形成（i < k-1）

──────────────────────────────────────────────────────────

步驟 1: i=1, nums[1]=3
───────────────────────────────
nums:  {1   3} -1  -3   5   3   6   7
index:  0   1   2   3   4   5   6   7

deque: [0] → 檢查：nums[0]=1 < nums[1]=3
       移除 0（因為 3 更大，1 永遠不會是最大值）

deque: [1]
       →
操作：移除所有比 3 小的，加入索引 1
窗口未形成（i < k-1）

──────────────────────────────────────────────────────────

步驟 2: i=2, nums[2]=-1
───────────────────────────────
nums:  {1   3  -1} -3   5   3   6   7
index:  0   1   2   3   4   5   6   7

deque: [1] → 檢查：nums[1]=3 > nums[2]=-1
       保留 1（3 比 -1 大）

deque: [1, 2]
       →
操作：-1 比 3 小，直接加在後面
窗口形成！最大值 = nums[1] = 3 ✓

──────────────────────────────────────────────────────────

步驟 3: i=3, nums[3]=-3
───────────────────────────────
nums:   1  {3  -1  -3}  5   3   6   7
index:  0   1   2   3   4   5   6   7

1. 檢查窗口：deque[0]=1 < i-k+1=1？否，保留
2. 檢查遞減：nums[2]=-1 > nums[3]=-3？是，保留

deque: [1, 2, 3]
       →
操作：加入索引 3
最大值 = nums[1] = 3 ✓

──────────────────────────────────────────────────────────

步驟 4: i=4, nums[4]=5
───────────────────────────────
nums:   1   3 {-1  -3   5}  3   6   7
index:  0   1   2   3   4   5   6   7

1. 檢查窗口：deque[0]=1 < i-k+1=2？是！移除索引 1
   deque: [2, 3]

2. 檢查遞減：nums[3]=-3 < nums[4]=5？是！移除索引 3
   deque: [2]

3. 檢查遞減：nums[2]=-1 < nums[4]=5？是！移除索引 2
   deque: []

deque: [4]
       →
操作：5 最大，清空舊的，加入索引 4
最大值 = nums[4] = 5 ✓

──────────────────────────────────────────────────────────

步驟 5: i=5, nums[5]=3
───────────────────────────────
nums:   1   3  -1 {-3   5   3}  6   7
index:  0   1   2   3   4   5   6   7

1. 檢查窗口：deque[0]=4 < i-k+1=3？否，保留
2. 檢查遞減：nums[4]=5 > nums[5]=3？是，保留

deque: [4, 5]
       →
操作：3 比 5 小，加在後面
最大值 = nums[4] = 5 ✓

──────────────────────────────────────────────────────────

步驟 6: i=6, nums[6]=6
───────────────────────────────
nums:   1   3  -1  -3  {5   3   6}  7
index:  0   1   2   3   4   5   6   7

1. 檢查窗口：deque[0]=4 < i-k+1=4？否，保留
2. 檢查遞減：nums[5]=3 < nums[6]=6？是！移除索引 5
   deque: [4]
3. 檢查遞減：nums[4]=5 < nums[6]=6？是！移除索引 4
   deque: []

deque: [6]
       →
操作：6 最大，清空舊的，加入索引 6
最大值 = nums[6] = 6 ✓

──────────────────────────────────────────────────────────

步驟 7: i=7, nums[7]=7
───────────────────────────────
nums:   1   3  -1  -3   5  {3   6   7}
index:  0   1   2   3   4   5   6   7

1. 檢查窗口：deque[0]=6 < i-k+1=5？否，保留
2. 檢查遞減：nums[6]=6 < nums[7]=7？是！移除索引 6
   deque: []

deque: [7]
       →
操作：7 最大，清空舊的，加入索引 7
最大值 = nums[7] = 7 ✓

──────────────────────────────────────────────────────────

最終結果：[3, 3, 5, 5, 6, 7]
```

### 核心性質

**Deque 維護的是「遞減序列的索引」：**

```
範例在 i=5 時：
deque: [4, 5]
        ↓  ↓
nums:  [5, 3]  ← 遞減！

為什麼？
- 如果新元素比隊尾大 → 隊尾永遠不可能是最大值 → 移除
- 如果新元素比隊尾小 → 可能在未來某個窗口成為最大值 → 保留

隊首永遠是當前窗口的最大值！
```

---

## Go 語法補充

### Slice 切片語法：`[start:end]`

```go
slice[start:end]
```
- `start`：起始索引（**包含**）
- `end`：結束索引（**不包含**）

**範例：**
```go
arr := []int{10, 20, 30, 40, 50}
//  索引：      0   1   2   3   4
n := len(arr)  // n = 5

result := arr[0:3]
// 結果：[10, 20, 30]
// 包含索引：0, 1, 2（不包含索引 3）

result := arr[0:n-1]
// 結果：[10, 20, 30, 40]
// 包含索引：0, 1, 2, 3（移除最後一個元素）
```

**記憶技巧：**
```go
[start:end] 的長度 = end - start
```

例如：`[0:4]` 的長度 = 4 - 0 = 4 個元素

所以 `[0:n-1]` 的長度 = (n-1) - 0 = n-1 個元素

**總結：`n-1` 是位置（索引），語意是「到索引 n-1 之前停止」，最終包含 n-1 個元素（索引 0 到 n-2）。**

### Container/Heap 包運作原理

Go 的 `container/heap` 包在調用 `heap.Pop(h)` 時會自動處理 swap 和堆調整：

```go
// container/heap 包的實作（簡化版）
func Pop(h Interface) interface{} {
    n := h.Len() - 1
    h.Swap(0, n)           // ← swap 堆頂和最後一個元素
    down(h, 0, n)          // 向下調整堆，維持堆性質
    return h.Pop()         // ← 最後才呼叫你定義的 Pop() 方法
}
```

**你的 `Pop()` 方法只負責：**

```go
func (h *MaxHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]       // 取最後一個元素（已經被 swap 到最後了）
    *h = old[0 : n-1]   // 縮短 slice
    return x
}
```

**完整執行順序範例：**

```
假設堆是 [10, 8, 6, 3, 1]（最大堆）

呼叫 heap.Pop(h) 時：

1. container/heap 執行 h.Swap(0, 4) → [1, 8, 6, 3, 10]
2. container/heap 執行 down() 調整堆 → [8, 3, 6, 1, 10]
3. container/heap 呼叫你的 h.Pop()
   - 取出 old[4] = 10
   - 堆變成 [8, 3, 6, 1]
4. 返回 10
```

**總結：** `container/heap` 包幫你做了 swap 和堆調整，你的 `Pop()` 只是輔助方法，負責返回最後一個元素並縮短 slice。

---

## 實際應用場景分析

### Monotonic Deque vs Heap + HashMap

這是一個很重要的問題：既然 Monotonic Deque 更優秀，為什麼交易所（Binance、OKX）的訂單簿不使用它？

#### 訂單簿的操作特性

```go
type OrderBook struct {
    bids map[float64][]*Order  // 買單（價格 → 訂單列表）
    asks map[float64][]*Order  // 賣單
    bestBid *Heap              // 最優買價
    bestAsk *Heap              // 最優賣價
}

// 操作類型：
1. 新增訂單（任意價格）
2. 取消訂單（任意訂單ID）
3. 部分成交（修改數量）
4. 查詢最優價格
5. 查詢某價格的深度
```

#### 能力對比

| 需求 | Monotonic Deque | Heap + HashMap |
|------|-----------------|----------------|
| 隨機插入任意價格的訂單 | ❌ 破壞單調性，需 O(n) 重建 | ✅ O(log n) |
| 隨機刪除特定訂單ID | ❌ 無法定位 | ✅ HashMap O(1) 定位 + Heap 更新 |
| 部分成交修改訂單 | ❌ 無法修改中間元素 | ✅ HashMap 定位 + 更新 |
| 查詢最優價格 | ✅ O(1) | ✅ O(1) |
| 查詢某價格深度 | ❌ 無法按價格查詢 | ✅ HashMap O(1) |

#### 問題範例

```
假設買單價格隊列（從高到低）：
Deque: [100, 99, 98, 97, 96]

場景1：用戶下了一個價格 95 的買單
→ 直接 append？但不能保證單調性
→ 要重新構建整個 deque？O(n)

場景2：用戶取消了價格 98 的訂單
→ Deque 無法直接刪除中間元素
→ 要重新構建整個 deque？O(n)

場景3：價格 99 的訂單部分成交，數量改變
→ 如果隊列空了，需要移除 99
→ 但 99 在中間，無法高效移除

場景4：查詢價格 98 的所有訂單
→ Deque 只存價格，沒有訂單詳情
→ 需要額外的數據結構
```

### Monotonic Deque 的核心限制

#### 限制 1：只能處理「滑動窗口」問題

**必須滿足：**
- 窗口**連續移動**
- 每次只**增加一個**、**移除一個**元素
- 查詢的範圍是**固定大小**或**連續區間**

#### 限制 2：只能處理「區間極值」問題

**能回答：**
- ✅ 這個區間的最大值/最小值是多少？

**無法回答：**
- ❌ 找出所有 > 某個值的元素
- ❌ 按照多個條件排序
- ❌ 刪除中間某個特定元素

### 適用場景對比表

| 特性 | Monotonic Deque | Heap + HashMap |
|------|-----------------|----------------|
| 最優值查詢 | O(1) | O(1) |
| 順序插入 | O(1) 均攤 | O(log n) |
| 隨機插入 | ❌ O(n) | ✅ O(log n) |
| 隨機刪除 | ❌ O(n) | ✅ O(log n) |
| 按鍵查詢 | ❌ 不支持 | ✅ O(1) |
| 空間複雜度 | O(k) 窗口大小 | O(n) 全部數據 |
| 適用場景 | 滑動窗口 | 動態優先隊列 |

### 實際應用建議

#### 選擇 Monotonic Deque 的場景：

```
✅ 固定/滑動窗口問題
✅ 只需要區間極值
✅ 數據流式處理
✅ 內存受限場景

範例：
- 股票價格的 N 天移動最高價
- 實時監控的滑動窗口異常檢測
- 最近 1000 個請求的最大延遲
- 滑動時間窗口內的峰值流量
- Next Greater Element 問題
- 直方圖最大矩形面積
```

#### 選擇 Heap + HashMap 的場景：

```
✅ 需要隨機插入/刪除
✅ 需要多維度查詢
✅ 需要修改元素優先級
✅ 訂單簿、任務調度等場景

範例：
- 交易所訂單簿（Binance、OKX）
- 任務優先隊列
- Dijkstra 最短路徑
- 支持任意插入/刪除的排序結構
- 需要持久化/回溯的場景
```

#### 不適用 Monotonic Deque 的場景：

```
❌ 需要隨機訪問/修改的數據結構
   - 訂單簿
   - 任務優先隊列

❌ 需要多維度查詢
   - 按價格查詢
   - 按時間查詢
   - 按用戶查詢

❌ 需要持久化/回溯
   - 需要查詢歷史狀態
   - 需要支持 undo/redo
```

---

## 總結

**Monotonic Deque 是「滑動窗口區間極值」的最優解，但不是「通用優先隊列」的最優解。**

### 關鍵要點

1. **Monotonic Deque 的優勢：**
   - 滑動窗口問題的最優時間複雜度 O(n)
   - 最優空間複雜度 O(k)
   - 實現優雅，每個元素最多進出隊列一次

2. **Monotonic Deque 的限制：**
   - 只適用於連續滑動窗口
   - 無法處理隨機插入/刪除
   - 無法支持多維度查詢

3. **選擇原則：**
   - 如果你的問題是**連續滑動窗口**求**區間最大/最小值** → 使用 Monotonic Deque
   - 如果你需要**隨機操作**、**多維度查詢** → 使用 Heap + HashMap 或其他數據結構

**選擇合適的數據結構，取決於你的具體使用場景！** 不要盲目追求「最優」算法，而是要理解每個算法的適用範圍。
