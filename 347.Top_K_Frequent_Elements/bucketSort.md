# 桶排序解法 (Bucket Sort)

## 核心概念

桶排序是一種**非比較型排序算法**，當數據範圍有限且已知時，可以達到 O(n) 的時間複雜度。

在這道題中，我們利用一個關鍵洞察：
- **頻率的範圍是固定的**：最小為 1，最大為 `len(nums)`
- 可以用**數組索引直接表示頻率**，避免排序

---

## 算法步驟

### 1. 統計每個數字的出現頻率

```go
freq := make(map[int]int)
for i := range nums {
    freq[nums[i]]++
}
```

**例如**：`nums = [1,1,1,2,2,3]`
```
freq = {
    1: 3,
    2: 2,
    3: 1
}
```

---

### 2. 創建頻率數組（桶）

```go
freqAr := make([][]int, len(nums) + 1)
```

**關鍵設計**：
- 數組大小：`len(nums) + 1`（頻率範圍 0 到 len(nums)）
- `freqAr[i]` 存儲所有出現頻率為 `i` 的數字

**為什麼是二維數組？**
- 可能有多個數字出現相同頻率
- 例如：`[1,2,3]` 中，1、2、3 都出現 1 次

---

### 3. 將數字放入對應頻率的桶

```go
for k, v := range freq {
    freqAr[v] = append(freqAr[v], k)
}
```

**圖解**：`nums = [1,1,1,2,2,3]`

```
freqAr 索引      存儲的數字         含義
    0       →   []              (無數字出現 0 次)
    1       →   [3]             3 出現 1 次
    2       →   [2]             2 出現 2 次
    3       →   [1]             1 出現 3 次
    4       →   []
    5       →   []
    6       →   []
```

---

### 4. 從高頻到低頻取出 k 個數字

```go
result := []int{}

for i := len(freqAr)-1; i >= 0 && k > 0; i-- {
    for j := len(freqAr[i]) - 1; j >= 0 && k > 0; j-- {
        result = append(result, freqAr[i][j])
        k--
    }
}

return result
```

**執行過程**（k=2）：
```
i=6: freqAr[6] = [] → 跳過
i=5: freqAr[5] = [] → 跳過
i=4: freqAr[4] = [] → 跳過
i=3: freqAr[3] = [1] → 取出 1，k=1
i=2: freqAr[2] = [2] → 取出 2，k=0
k=0 → 結束

result = [1, 2] ✓
```

---

## 完整代碼

```go
func topKFrequent(nums []int, k int) []int {
    // 1. 統計頻率
    freq := make(map[int]int, len(nums)/2)
    for i := range nums {
        freq[nums[i]]++
    }

    // 2. 創建頻率數組（桶）
    freqAr := make([][]int, len(nums) + 1)

    // 3. 將數字放入對應頻率的桶
    for num, count := range freq {
        freqAr[count] = append(freqAr[count], num)
    }

    // 4. 從高頻到低頻取 k 個
    result := []int{}

    for i := len(freqAr)-1; i >= 0 && k > 0; i-- {
        for j := len(freqAr[i]) - 1; j >= 0 && k > 0; j-- {
            result = append(result, freqAr[i][j])
            k--
        }
    }

    return result
}
```

---

## 複雜度分析

### 時間複雜度：O(n)

1. **統計頻率**：O(n)
   - 遍歷 nums 一次

2. **建桶**：O(m)
   - 遍歷 freq（m = 唯一數字個數，m ≤ n）

3. **取 k 個元素**：O(k)
   - 最多遍歷 k 個元素

**總時間**：O(n + m + k) = **O(n)**

### 空間複雜度：O(n)

- `freq` map：O(m)
- `freqAr` 數組：O(n)（最壞情況，每個索引都有元素）
- `result` 數組：O(k)

**總空間**：O(n)

---

## 為什麼桶排序在這題最快？

### 對比三種方法

| 方法 | 時間複雜度 | 空間複雜度 | 說明 |
|------|-----------|-----------|------|
| **排序** | O(m log m) | O(m) | 對頻率排序 |
| **MaxHeap** | O(n + m log m + k log m) | O(m) | 建堆 + pop k 次 |
| **桶排序** | **O(n)** | O(n) | 利用頻率範圍有限 |

### 關鍵優勢

1. ✅ **無需比較排序**
   - 直接用頻率作為索引
   - 避免 O(log n) 的比較開銷

2. ✅ **線性時間**
   - 所有操作都是 O(1) 或 O(n)
   - 無對數複雜度

3. ✅ **簡潔直觀**
   - 代碼短小精悍
   - 邏輯清晰易懂

---

## 詳細示例

### Example 1
```
輸入：nums = [1,1,1,2,2,3], k = 2

步驟 1：統計頻率
freq = {1:3, 2:2, 3:1}

步驟 2：創建頻率數組
freqAr = [[], [], [], [], [], [], []]
         0   1   2   3   4   5   6

步驟 3：填充桶
freqAr = [[], [3], [2], [1], [], [], []]
         0    1    2    3   4   5   6
              ↑    ↑    ↑
           出現1次 2次 3次

步驟 4：從後往前取 k=2 個
i=3: 取出 1, k=1
i=2: 取出 2, k=0
結束

輸出：[1, 2]
```

### Example 2
```
輸入：nums = [1,2,1,2,1,2,3,1,3,2], k = 2

步驟 1：統計頻率
freq = {1:4, 2:4, 3:2}

步驟 3：填充桶
freqAr[2] = [3]
freqAr[4] = [1, 2]

步驟 4：從後往前取 k=2 個
i=4: freqAr[4] = [1, 2]
     取出 2, k=1
     取出 1, k=0
結束

輸出：[2, 1] 或 [1, 2]（順序無所謂）
```

---

## 適用場景

桶排序特別適合以下情況：

✅ **數據範圍有限且已知**
- 頻率範圍：1 到 len(nums)
- 可以用數組索引表示

✅ **不需要完全排序**
- 只需要前 k 個元素
- 不用排序所有數據

✅ **追求極致性能**
- O(n) 時間複雜度
- 在 LeetCode 上通常是最快解法

❌ **不適合的情況**
- 數據範圍很大（例如：0 到 10^9）
- 需要完整排序結果
- 空間受限（桶排序需要額外數組）

---

## 延伸思考

### Q1: 如果頻率範圍很大怎麼辦？

**例如**：nums 可能包含 -10^9 到 10^9 的數字

**答案**：改用 MaxHeap 或排序
- 桶排序不適合，數組太大
- MaxHeap：O(n log k)
- 排序：O(m log m)

### Q2: 為什麼不用 MinHeap？

MinHeap 維護大小為 k 的堆，也很高效：
```go
// 維護大小為 k 的 MinHeap
// 如果新元素頻率 > 堆頂，替換堆頂
// 時間複雜度：O(n log k)
```

但在這道題中：
- **桶排序 O(n) < MinHeap O(n log k)**
- k 可能很大時，桶排序優勢明顯

### Q3: 為什麼從後往前遍歷？

```go
for i := len(freqAr)-1; i >= 0 && k > 0; i-- {
    // ...
}
```

因為索引越大，頻率越高：
- freqAr[6] 存的是出現 6 次的數字
- freqAr[1] 存的是出現 1 次的數字

我們要的是**頻率最高**的 k 個，所以從後往前！

---

## 總結

桶排序在 Top K Frequent Elements 中的應用：

🎯 **核心思想**：用數組索引表示頻率，避免排序

🚀 **時間複雜度**：O(n)，擊敗 99%+ 的提交

💡 **關鍵技巧**：
1. 頻率範圍有限（1 到 len(nums)）
2. 二維數組處理相同頻率
3. 從高頻到低頻遍歷

📚 **學習重點**：
- 理解桶排序的適用場景
- 掌握數組索引的巧妙運用
- 認識非比較排序的威力
