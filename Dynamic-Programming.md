# Dynamic Programming (DP) 動態規劃

## 目錄
- [核心思想](#核心思想)
- [辨識題型](#辨識題型)
- [二維 DP：兩序列問題](#二維-dp兩序列問題)
- [代碼模板](#代碼模板)
- [實例解析：1458. Max Dot Product](#實例解析1458-max-dot-product)
- [複雜度分析](#複雜度分析)
- [相關題目](#相關題目)

---

## Reference

- 70\. Climbing Stairs
- 198\. House Robber
- 1143\. Longest Common Subsequence (LCS)
- 1458\. Max Dot Product of Two Subsequences

---

## 核心思想

**「把大問題拆成小問題，記住算過的結果」**

| 特性 | 說明 |
|-----|------|
| **重疊子問題** | 大問題可以拆成小問題，而且小問題會重複出現 |
| **最優子結構** | 大問題的最佳解，可以由小問題的最佳解組合而成 |
| **記憶化** | 把算過的結果存起來，不重複計算 |

---

## 辨識題型

### 看到這些關鍵字 → 想到 DP

| 關鍵字 | 例子 |
|-------|------|
| 最大/最小 (max/min) | "maximum profit", "minimum cost" |
| 計數 (count) | "number of ways", "how many" |
| 是否可能 (possible) | "can you achieve", "is it possible" |
| 最長/最短 | "longest subsequence", "shortest path" |

### 兩序列問題 → 二維 DP

```
看到題目
    │
    ▼
┌─────────────────┐
│ 有「兩個序列」？ │ ──Yes──→ 二維 DP：dp[i][j]
└─────────────────┘
    │
    ▼
┌─────────────────┐
│ 是「子序列」？   │ ──Yes──→ 可跳過：看上方、左方
└─────────────────┘
    │
    ▼
┌─────────────────┐
│ 要「配對」？     │ ──Yes──→ 延續：看左上角
└─────────────────┘
    │
    ▼
┌─────────────────┐
│ 求「最大/最小」？│ ──Yes──→ 用 max() 或 min()
└─────────────────┘
```

---

## 二維 DP：兩序列問題

### 狀態定義

```
dp[i][j] = 考慮 nums1[0..i] 和 nums2[0..j] 時的最佳解
```

### 轉移來源

```
┌─────────┬─────────┐
│  左上   │   上    │   左上 = 延續配對（兩邊都選）
│(i-1,j-1)│ (i-1,j) │   上   = 跳過 nums1[i]
├─────────┼─────────┤   左   = 跳過 nums2[j]
│   左    │ 當前格  │
│ (i,j-1) │  (i,j)  │
└─────────┴─────────┘
```

### 轉移方程（通用）

```go
// 對於每個 dp[i][j]，考慮：
dp[i][j] = 選擇最佳的(
    當前配對的結果,              // nums1[i] 配 nums2[j]
    dp[i-1][j-1] + 當前配對,     // 延續之前 + 當前配對
    dp[i-1][j],                  // 跳過 nums1[i]
    dp[i][j-1],                  // 跳過 nums2[j]
)
```

---

## 代碼模板

### 兩序列子序列問題模板

```go
func twoSequenceDP(nums1 []int, nums2 []int) int {
    m, n := len(nums1), len(nums2)
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    for i := range m {
        for j := range n {
            // 1. 當前配對（重新開始或基礎情況）
            dp[i][j] = nums1[i] * nums2[j]

            // 2. 延續之前的配對 + 當前配對
            if i > 0 && j > 0 {
                dp[i][j] = max(dp[i][j], dp[i-1][j-1] + nums1[i]*nums2[j])
            }

            // 3. 跳過 nums1[i]
            if i > 0 {
                dp[i][j] = max(dp[i][j], dp[i-1][j])
            }

            // 4. 跳過 nums2[j]
            if j > 0 {
                dp[i][j] = max(dp[i][j], dp[i][j-1])
            }
        }
    }

    return dp[m-1][n-1]
}
```

---

## 實例解析：1458. Max Dot Product

### 題目

給定兩個陣列 `nums1` 和 `nums2`，找出兩個等長子序列的最大點積。

### 關鍵字分析

| 關鍵字 | 對應 |
|-------|------|
| Two arrays | 二維 DP |
| Subsequences | 可跳過 → 上/左 |
| Same length | 配對 → 左上 |
| Maximum | max() |

### 完整範例

```
nums1 = [2, 1, -2, 5], nums2 = [3, 0, -6]
```

**DP 表格：**

```
              j=0[3]    j=1[0]    j=2[-6]
           +--------+--------+--------+
  i=0 [2]  |   6    |   6    |   6    |
           +--------+--------+--------+
  i=1 [1]  |   6    |   6    |   6    |
           +--------+--------+--------+
  i=2 [-2] |   6    |   6    |   18   |
           +--------+--------+--------+
  i=3 [5]  |   15   |   15   |   18   |
           +--------+--------+--------+
```

**關鍵格子 dp[2][2] = 18：**

```go
dp[2][2] = max(
    -2 * -6,                    // 12（只選這一對）
    dp[1][1] + (-2)*(-6),       // 6 + 12 = 18 ★（延續 + 這對）
    dp[1][2],                   // 6（跳過 -2）
    dp[2][1],                   // 6（跳過 -6）
)
= 18
```

**對應的最佳子序列：**
- `[2, -2]` 配 `[3, -6]` → 2×3 + (-2)×(-6) = 18
- 或 `[2, 1, -2]` 配 `[3, 0, -6]` → 6 + 0 + 12 = 18

### 為什麼每格只需要看三個鄰居？

```
┌───────────────────────────────────────────────────────┐
│ 每格不需要重新比較所有子序列組合                       │
│ 因為鄰居格子已經算好了「到那個位置為止的最佳解」       │
│                                                       │
│ 當前格只需要決定：                                    │
│ 「要不要用當前的 nums1[i] 和 nums2[j]？」             │
│                                                       │
│ - 要用 → 從左上延續，或單獨開始                       │
│ - 不用其中一個 → 繼承上方或左方的最佳解               │
└───────────────────────────────────────────────────────┘
```

---

## 複雜度分析

### 時間複雜度
- **O(m × n)**
- 每個格子計算一次，每次 O(1)

### 空間複雜度
- **O(m × n)** - 標準二維陣列
- **O(min(m, n))** - 可優化成滾動陣列

---

## 相關題目

### 經典兩序列 DP

| 題目 | 轉移邏輯 |
|-----|---------|
| **1143. LCS** | 左上+1（相等）/ max(上, 左) |
| **72. Edit Distance** | 左上+0或1 / 上+1 / 左+1 |
| **1458. Max Dot Product** | 左上+乘積 / 上 / 左 / 單獨乘積 |
| **718. Maximum Length of Repeated Subarray** | 左上+1（相等）/ 0（子陣列，不能跳過）|

### 一維 DP 入門

| 題目 | 說明 |
|-----|------|
| **70. Climbing Stairs** | dp[i] = dp[i-1] + dp[i-2] |
| **198. House Robber** | dp[i] = max(dp[i-1], dp[i-2] + nums[i]) |
| **300. Longest Increasing Subsequence** | dp[i] = max(dp[j] + 1) for j < i |

---

## 總結

### DP 三步驟

1. **定義狀態**：`dp[i][j]` 代表什麼？
2. **找轉移方程**：當前狀態從哪些狀態轉移而來？
3. **處理邊界**：初始值是什麼？

### 兩序列問題口訣

```
兩序列 → 二維表
子序列 → 可跳過（上、左）
要配對 → 左上角
求最優 → max / min
```

### 與遞迴的關係

DP 本質上是「**自底向上的遞迴**」：
- 遞迴：從大問題往小問題拆（Top-down）
- DP：從小問題往大問題建（Bottom-up）

兩者邏輯相同，DP 透過表格避免重複計算。
